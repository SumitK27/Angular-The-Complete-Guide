# **State Management and Change Detection** <!-- omit in toc -->

This section will guide you on how to manage the state in your Angular application.

- [**Keeping Your View in Sync: Change Detection in Angular**](#keeping-your-view-in-sync-change-detection-in-angular)
  - [**Change Detection Explained:**](#change-detection-explained)
  - [**Different Change Detection Strategies:**](#different-change-detection-strategies)
  - [**Zone.js: The Change Detection Engine:**](#zonejs-the-change-detection-engine)
  - [**Signal-Based Change Detection (Angular 16+):**](#signal-based-change-detection-angular-16)
  - [**Choosing the Right Strategy:**](#choosing-the-right-strategy)
- [**Passing Data Downward**](#passing-data-downward)
  - [**Passing Data Downward: Using @Input in Angular**](#passing-data-downward-using-input-in-angular)
    - [**Understanding @Input:**](#understanding-input)
    - [**Using @Input in Action:**](#using-input-in-action)
    - [**Running the Application:**](#running-the-application)
    - [**Remember:**](#remember)
  - [**Passing Data Downward: Using Signals (Angular 16+)**](#passing-data-downward-using-signals-angular-16)
    - [**Signals: A More Granular Approach**](#signals-a-more-granular-approach)
    - [**Using Signals in Action:**](#using-signals-in-action)
    - [**Benefits of Signals:**](#benefits-of-signals)
    - [**Things to Consider:**](#things-to-consider)
  - [**Choosing the Right Approach:**](#choosing-the-right-approach)

## **Keeping Your View in Sync: Change Detection in Angular**
In Angular applications, keeping the displayed content (view) synchronized with the underlying data (model) is crucial. This is where change detection comes in.

### **Change Detection Explained:**

Imagine your Angular application as a living document. Any change in the data, like user interaction or data fetching, needs to be reflected in the UI. Change detection is the mechanism that ensures this happens seamlessly. Angular utilizes Zone.js, a library, to track these changes and trigger updates when necessary.

### **Different Change Detection Strategies:**

To optimize performance, Angular offers various change detection strategies. Here's a breakdown of the common ones:

  - **Default (CheckAlways):** This is the default strategy where Angular checks the entire component tree (all components and their children) whenever a change occurs - efficient for small applications but can be resource-intensive for large ones.
  - **OnPush:** This strategy is more performant, especially for complex applications. It only checks for changes when:
    - Input properties of the component are modified with a new reference (not just mutation of the same object).
    - Event listeners are triggered within the component's template.
  - **Detached (CheckOnce):** This strategy completely detaches the component from the change detection cycle. It's rarely used as you typically want components to react to changes in the application.

### **Zone.js: The Change Detection Engine:**

Zone.js plays a key role in change detection. It acts like a wrapper around asynchronous operations like promises, timers, and user events. When a change occurs within a Zone.js context, it triggers the change detection mechanism to update the view accordingly.

For every event happening Zone.js checks the entire component tree to see if any changes have occurred. This can be resource-intensive, especially in large applications. This is where more advanced change detection strategies like OnPush come into play.

```typescript
import { Component } from '@angular/core';
import { users } from './data';
import { randomIndex } from './utils';

@Component({
  selector: 'app-user-list',
  template: `
    <button (click)="onSelectUser()">
      <img [src]="imagePath" [alt]="selectedUser.name" />
      <span>{{ selectedUser.name }}</span>
    </button>
  `
})
export class UserListComponent {
  users = users;
  selectedUser = this.users[randomIndex(this.users.length)];
  imagePath = `assets/users/${this.selectedUser.avatar}`;
  
  onSelectUser() {
    this.selectedUser = this.users[randomIndex(this.users.length)];
    this.imagePath = `assets/users/${this.selectedUser.avatar}`;
  }
}
```

### **Signal-Based Change Detection (Angular 16+):**

Angular 16 introduces a new experimental feature: signal-based change detection. Here, changes are tracked and managed using "signals," which can be events, promises, or observables. This approach offers potential performance benefits by reducing the number of components checked during change detection.

```typescript
import { Component, signal, computed } from '@angular/core';
import { users } from './data';
import { randomIndex } from './utils';

@Component({
  selector: 'app-user-list',
  template: `
    <button (click)="onSelectUser()">
      <img [src]="imagePath()" [alt]="selectedUser().name" />
      <span>{{ selectedUser().name }}</span>
    </button>
  `
})
export class UserListComponent {
  users = users;
  selectedUser = signal(this.users[randomIndex(this.users.length)]);
  imagePath = computed(() => `assets/users/${this.selectedUser().avatar}`);
  
  onSelectUser() {
    this.selectedUser(this.users[randomIndex(this.users.length)]);
  }
}
```

Using `signal` and `computed` functions, you can define signals and computed properties that trigger change detection only when necessary. This can lead to better performance in large applications.

### **Choosing the Right Strategy:**

The ideal strategy depends on your application's size and complexity. Start with OnPush for most cases as it balances performance and flexibility. As your application grows, you can explore more advanced techniques like zone isolation and custom change detection strategies.

## **Passing Data Downward**

### **Passing Data Downward: Using @Input in Angular**

Components in Angular can work together to build complex user interfaces. Often, you'll need to pass data from a parent component to a child component for display or manipulation. This is where the @Input decorator comes in handy.

#### **Understanding @Input:**

The `@Input` decorator establishes a one-way data binding channel between parent and child components. This means changes in the parent component's data are reflected in the child component, but not the other way around.

#### **Using @Input in Action:**

Let's create a simple example:

1. Child Component (`app-child.component.ts`):

   - Define a child component named `ChildComponent`.
   - Import` @Input` from `@angular/core`.
   - Decorate two properties (`title` and `content`) with `@Input()`. This tells Angular that these properties will receive data from the parent component.
   - Define a template (`app-child.component.html`) that displays the received title and content using interpolation.

    ```typescript
    import { Component, Input } from '@angular/core';

    @Component({
      selector: 'app-child',
      template: `
        <h2>{{ title }}</h2>
        <p>{{ content }}</p>
      `
    })
    export class ChildComponent {
      @Input({ required: true }) title!: string;
      @Input({ required: true }) content!: string;
    }
    ```

    Note:

   - Adding `!` to the property declaration tells TypeScript that the property will be initialized by Angular and won't be `null` or `undefined`. This is known as the non-null assertion operator. This might be an issue if the property is not provided by the parent component and you don't want it to be `null`.
   - The `required: true` option is available in Angular 13+ to enforce the presence of the input property. If the property is not provided by the parent component, Angular will throw an error.

2. Parent Component (`app-parent.component.ts`):

   - Define a parent component named `ParentComponent`.
   - Define properties (`parentTitle` and `parentContent`) with the data you want to pass down.
   - In the template (`app-parent.component.html`), use the child component selector (`<app-child>`) and property binding (`[]`). Within the brackets, specify the parent component's properties mapped to the child component's `@Input` decorated properties.

    ```typescript
    import { Component } from '@angular/core';

    @Component({
      selector: 'app-parent',
      template: `
        <app-child [title]="parentTitle" [content]="parentContent"></app-child>
      `
    })
    export class ParentComponent {
      parentTitle = 'Data from Parent';
      parentContent = 'This content is passed from the parent component.';
    }
    ```

#### **Running the Application:**

When you run your Angular application, the child component will receive the title and content values from the parent component and display them on the screen. Any changes you make to the parent component's properties will be reflected in the child component, showcasing the one-way data flow.

#### **Remember:**

`@Input` creates a one-way data binding. Changes in the child component won't affect the parent component's data.
You can use this approach to pass various types of data, not just strings.

### **Passing Data Downward: Using Signals (Angular 16+)**

While `@Input` is a reliable way to establish one-way data binding between components, Angular 16 introduces a potentially more efficient approach: signals. Here's how they work:

#### **Signals: A More Granular Approach**

Signals offer a more fine-grained way to manage data flow compared to @Input. They act as dedicated communication channels that track changes and trigger updates only when necessary. This can improve performance, especially in complex applications.

#### **Using Signals in Action:**

Let's revisit the previous example using signals:

1. Child Component (app-child.component.ts):

- Define a child component named `ChildComponent`.
- Import input from `@angular/core`.
- Use the input function to create signals for title and content.
- Set the type for each signal using `input.required<string>()`. This ensures the parent component provides the required data type and throws an error if not.
- Access the signal values using function calls like `title()` and `content()`.
In the template (`app-child.component.html`), display the values received from the signals.

```typeScript
import { Component, input } from '@angular/core';

@Component({
  selector: 'app-child',
  template: `
    <h2>{{ title() }}</h2>
    <p>{{ content() }}</p>
  `
})
export class ChildComponent {
  title = input.required<string>();
  content = input.required<string>();
}
```

2. Parent Component (Similar to using `@Input`)

    The parent component remains largely unchanged. You'll still define the data properties and pass them to the child component using property binding. However, these properties will be bound to the signals defined in the child component.


#### **Benefits of Signals:**

- **Improved Performance:** Signals can potentially enhance performance by avoiding unnecessary change detection cycles compared to `@Input`.
- **Granular Control:** You can define custom logic for handling updates based on signal changes.

#### **Things to Consider:**

- Signals are a newer feature (introduced in Angular 16).
- They require a slightly different syntax compared to `@Input`.
- You cannot set a new value to input signals as they are *read-only*.

### **Choosing the Right Approach:**

For simple data binding scenarios, `@Input` remains a solid choice. However, as your application grows and performance becomes critical, exploring signals can provide more control and potential performance gains.
